#!/usr/bin/env bash

################################################################################
#                                                                              #
# ImposTor                                                                     #
#                                                                              #
# version: 1.1.2                                                               #
#                                                                              #
# Cross-Distro Transparent Proxy through Tor                                   #
#                                                                              #
# Copyright (C) 2025                                                           #
#                                                                              #
# Inspired by kalitorify, anonsurf and other tools                             #
#                                                                              #
# Works on most linux distros unlike others which are optimised for            #
# specific scenarios.                                                          #
#                                                                              #
# GNU GENERAL PUBLIC LICENSE                                                   #
#                                                                              #
# This program is free software: you can redistribute it and/or modify         #
# it under the terms of the GNU General Public License as published by         #
# the Free Software Foundation, either version 3 of the License, or            #
# (at your option) any later version.                                          #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program.  If not, see <http://www.gnu.org/licenses/>.        #
#                                                                              #
################################################################################

readonly prog_name="ImposTOR"
readonly version="1.1.2"
readonly signature="GNU GPL version 3"

export red="$(tput setaf 1)"
export red="$(tput setaf 1)"
export green="$(tput setaf 2)"
export blue="$(tput setaf 4)"
export white="$(tput setaf 7)"
export b="$(tput bold)"
export reset="$(tput sgr0)"

readonly backup_dir="/tmp/crocodisle_backups"   # temporary backups

readonly trans_port="9040"

# Tor DNSPort
readonly dns_port="5353"

# Tor VirtualAddrNetworkIPv4 and IPv6
readonly virtual_address_ipv4="10.192.0.0/10"
readonly virtual_address_ipv6="fc00::/7"

# LAN destinations that shouldn't be routed through Tor (IPv4 and IPv6)
readonly non_tor_ipv4="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"
readonly non_tor_ipv6="::1/128 fc00::/7 fe80::/10"

# Multicast ranges to drop for safety (mDNS etc.)
readonly multicast_ipv4="224.0.0.0/4"
readonly multicast_ipv6="ff00::/8"

## IP change interval (default 0 = disabled)
ip_change_interval=0  # in seconds

## PID for auto-restart background process
auto_restart_pid=""

skip() {
    printf "${red}%s${reset}\\n" "[ERROR] $*" >&2
}

die() {
    printf "${red}%s${reset}\\n" "[ERROR] $*" >&2
    exit 1
}

info() {
    printf "${b}${blue}%s${reset} ${b}%s${reset}\\n" "::" "${@}"
}

msg() {
    printf "${b}${green}%s${reset} %s\\n\\n" "[OK]" "${@}"
}

query() {
    printf "${b}${green}%s${reset} %s" "$ » "
}

check_root() {
    if [[ "${UID}" -ne 0 ]]; then
        die "R U N   T H I S   S C R I P T   I N   R O O T"
    fi
}

banner() {
    printf "%s\\n\\n" "${red}${b}


    ██▓ ███▄ ▄███▓ ██▓███    ▒█████     ██████  █████████▓ ▒█████   ██▀███  
    ▓██▒ ▓██▒▀█▀ ██ ▒▓██░  ██▒ ▒██▒  ██▒▒ ██    ▒   ▓██▒▓▒ ▒██▒  ██▒ ▓██ ▒ ██▒
    ▒██▒ ▓██    ▓██ ░▓██░ ██▓▒ ▒██░  ██▒░  ▓██▄   ▒ ▓██░▒ ░▒██░  ██▒ ▓██ ░▄█ ▒
    ░██░ ▒██    ▒██  ▒██▄█▓▒ ▒ ▒██   ██░   ▒   ██▒░ ▓██▓░  ▒██   ██░ ▒██▀▀█▄  
    ░██░ ▒██▒   ░██▒ ▒██▒ ░  ░  ░████▓▒░ ▒██████▒▒  ▒██▒░   ░████▓▒░ ░██▓ ▒██▒
    ░▓  ░  ▒░   ░  ░ ▒▓▒░ ░  ░░  ▒░▒░▒░ ▒  ▒▓▒ ▒ ░  ▒ ░░    ░▒░▒░▒░  ░ ▒▓ ░▒▓░
    ▒ ░░  ░      ░░ ▒ ░       ░ ▒ ▒░ ░ ░▒   ░ ░    ░       ░▒ ▒░    ░▒ ░ ▒░
    ▒ ░░      ░   ░ ░       ░ ░ ░ ▒  ░  ░   ░    ░       ░ ░░ ▒     ░░   ░ 
    ░         ░                ░ ░        ░                ░ ░      ░     

    ${reset}"
    printf "%s\\n\\n" "» λ QT CHAATHAN product₍˄·͈༝·͈˄₎◞ ̑̑"
}

## Detect Tor UID dynamically (works across distros)
get_tor_uid() {
    tor_uid=$(ps -o uid= -C tor 2>/dev/null | head -n1 | tr -d ' ')
    if [[ -z "$tor_uid" ]]; then
        # Fallback for different user names
        tor_uid=$(id -u debian-tor 2>/dev/null || id -u tor 2>/dev/null)
    fi
    if [[ -z "$tor_uid" ]]; then
        die "Unable to detect Tor user UID. Ensure Tor is installed."
    fi
    echo "$tor_uid"
}

## Configure general settings
#
# - packages: tor, curl, iptables, ip6tables
# - temporary backups
# - temporary torrc modifications
setup_general() {
    info "Checking program settings..."

    # packages
    declare -a dependencies=('tor' 'curl' 'iptables' 'ip6tables')
    for package in "${dependencies[@]}"; do
        if ! hash "${package}" 2>/dev/null; then
            die "'${package}' isn't installed, exit"
        fi
    done

    # Create backup dir if not exists
    mkdir -p "${backup_dir}"

    # Backup and modify torrc temporarily
    if [[ ! -f /etc/tor/torrc ]]; then
        die "/etc/tor/torrc file not exist, check Tor configuration"
    fi

    printf "%s\\n" "Temporarily configuring /etc/tor/torrc for TransPort and DNSPort"

    if ! cp -f /etc/tor/torrc "${backup_dir}/torrc.backup"; then
        die "can't backup '/etc/tor/torrc'"
    fi

    # Append necessary configs if not present (temporary, will restore on stop)
    {
        echo "TransPort 0.0.0.0:${trans_port} IsolateSOCKSAuth"
        echo "TransPort [::]:${trans_port} IsolateSOCKSAuth"
        echo "DNSPort 0.0.0.0:${dns_port}"
        echo "DNSPort [::]:${dns_port}"
        echo "VirtualAddrNetworkIPv4 ${virtual_address_ipv4}"
        echo "VirtualAddrNetworkIPv6 ${virtual_address_ipv6}"
        echo "AutomapHostsOnResolve 1"
    } >> /etc/tor/torrc

    # DNS settings: /etc/resolv.conf
    printf "%s\\n" "Configure resolv.conf to use Tor DNSPort"

    if ! cp /etc/resolv.conf "${backup_dir}/resolv.conf.backup"; then
        die "can't backup '/etc/resolv.conf'"
    fi

    printf "%s\\n" "nameserver 127.0.0.1" > /etc/resolv.conf
    printf "%s\\n" "nameserver ::1" >> /etc/resolv.conf  # For IPv6

    # Reload systemd if available
    if hash systemctl 2>/dev/null; then
        systemctl --system daemon-reload
    fi
}

## iptables and ip6tables settings
#
# Usage: setup_firewall <arg>
#
# args:
#       set -> set rules for Tor transparent proxy (IPv4/IPv6)
#       restore -> restore default rules
setup_firewall() {
    local tor_uid=$(get_tor_uid)

    case "$1" in
        set)
            printf "%s\\n" "Configuring iptable rules..."

            # Flush current rules
            iptables -F
            iptables -X
            iptables -t nat -F
            iptables -t nat -X
            ip6tables -F
            ip6tables -X
            ip6tables -t nat -F
            ip6tables -t nat -X

            # Default policies
            iptables -P INPUT ACCEPT
            iptables -P FORWARD ACCEPT
            iptables -P OUTPUT ACCEPT
            ip6tables -P INPUT ACCEPT
            ip6tables -P FORWARD ACCEPT
            ip6tables -P OUTPUT ACCEPT

            # *nat OUTPUT for IPv4
            # NAT .onion addresses
            iptables -t nat -A OUTPUT -d ${virtual_address_ipv4} -p tcp --syn -j REDIRECT --to-ports ${trans_port}

            # NAT DNS to Tor
            iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports ${dns_port}
            iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports ${dns_port}  # DoT

            # Exclude Tor, loopback, local nets
            iptables -t nat -A OUTPUT -m owner --uid-owner ${tor_uid} -j RETURN
            iptables -t nat -A OUTPUT -o lo -j RETURN
            for lan in ${non_tor_ipv4}; do
                iptables -t nat -A OUTPUT -d ${lan} -j RETURN
            done

            # Redirect TCP to TransPort
            iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports ${trans_port}

            # *filter for IPv4
            iptables -A INP   # temporary backupsUT -m state --state ESTABLISHED -j ACCEPT
            iptables -A INPUT -i lo -j ACCEPT
            iptables -A INPUT -j DROP

            iptables -A FORWARD -j DROP

            iptables -A OUTPUT -m conntrack --ctstate INVALID -j DROP
            iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
            iptables -A OUTPUT -m owner --uid-owner ${tor_uid} -j ACCEPT
            iptables -A OUTPUT -o lo -j ACCEPT
            iptables -A OUTPUT -d 127.0.0.1 -p tcp --dport ${trans_port} -j ACCEPT
            for lan in ${non_tor_ipv4}; do
                iptables -A OUTPUT -d ${lan} -j ACCEPT
            done

            # Drop non-DNS UDP (leaks prevention)
            iptables -A OUTPUT -p udp ! --dport 53 -j DROP

            # Drop multicast (mDNS safety)
            for mcast in ${multicast_ipv4}; do
                iptables -A OUTPUT -d ${mcast} -j DROP
            done

            iptables -A OUTPUT -j DROP

            iptables -P INPUT DROP
            iptables -P FORWARD DROP
            iptables -P OUTPUT DROP

            # IPv6 parallels
            ip6tables -t nat -A OUTPUT -d ${virtual_address_ipv6} -p tcp --syn -j REDIRECT --to-ports ${trans_port}

            ip6tables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports ${dns_port}
            ip6tables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports ${dns_port}

            ip6tables -t nat -A OUTPUT -m owner --uid-owner ${tor_uid} -j RETURN
            ip6tables -t nat -A OUTPUT -o lo -j RETURN
            for lan in ${non_tor_ipv6}; do
                ip6tables -t nat -A OUTPUT -d ${lan} -j RETURN
            done

            ip6tables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports ${trans_port}

            ip6tables -A INPUT -m state --state ESTABLISHED -j ACCEPT
            ip6tables -A INPUT -i lo -j ACCEPT
            ip6tables -A INPUT -j DROP

            ip6tables -A FORWARD -j DROP

            ip6tables -A OUTPUT -m conntrack --ctstate INVALID -j DROP
            ip6tables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT
            ip6tables -A OUTPUT -m owner --uid-owner ${tor_uid} -j ACCEPT
            ip6tables -A OUTPUT -o lo -j ACCEPT
            ip6tables -A OUTPUT -d ::1 -p tcp --dport ${trans_port} -j ACCEPT
            for lan in ${non_tor_ipv6}; do
                ip6tables -A OUTPUT -d ${lan} -j ACCEPT
            done

            # Drop non-DNS UDP IPv6
            ip6tables -A OUTPUT -p udp ! --dport 53 -j DROP

            # Drop multicast IPv6
            for mcast in ${multicast_ipv6}; do
                ip6tables -A OUTPUT -d ${mcast} -j DROP
            done

            ip6tables -A OUTPUT -j DROP

            ip6tables -P INPUT DROP
            ip6tables -P FORWARD DROP
            ip6tables -P OUTPUT DROP
        ;;

        restore)
            printf "%s\\n" "Restoring default firewall rules"

            iptables -F
            iptables -X
            iptables -t nat -F
            iptables -t nat -X
            iptables -P INPUT ACCEPT
            iptables -P FORWARD ACCEPT
            iptables -P OUTPUT ACCEPT

            ip6tables -F
            ip6tables -X
            ip6tables -t nat -F
            ip6tables -t nat -X
            ip6tables -P INPUT ACCEPT
            ip6tables -P FORWARD ACCEPT
            ip6tables -P OUTPUT ACCEPT
        ;;
    esac
}

## Check public IP address
check_ip() {
    local url_list=(
        'https://ipinfo.io/'
        'https://api.myip.com/'
        'https://ifconfig.me'
    )

    info "Checking public IP address"

    for url in "${url_list[@]}"; do
        local request="$(curl -s "$url")"
        local response="$?"

        if [[ "$response" -ne 0 ]]; then
            continue
        fi

        printf "%s\\n" "${request}"
        break
    done
}

## Check status of program and services
check_status() {
    info "Check current status of Tor service"

    if pgrep -x "tor" > /dev/null; then
        msg "Tor daemon is running"
    else
        skip "Tor is not running! Use 'start' to start ImposTOR or type 'help' for commands!"
        return 0
    fi

    # Check Tor connection
    local hostport="localhost:9050"
    local url="https://check.torproject.org/"

    if curl --socks5 "${hostport}" --socks5-hostname "${hostport}" -s "${url}" | grep -q "Congratulations"; then
        msg "Your system is configured to use Tor"
    else
        printf "${red}%s${reset}\\n\\n" "Your system is not using Tor!"
        printf "%s\\n" "Try restarting Tor with the 'Restart' option"
        return 1
    fi

    check_ip
}

start_proxy() {
    check_root

    if pgrep -x "tor" > /dev/null; then
        skip "Tor is already running, stopping it first!"
        sudo systemctl stop tor >/dev/null 2>&1
    fi

    setup_general

    printf "\\n"
    info "Starting ImposTOR!"

    # Start Tor (use systemctl if available, else direct)
    printf "%s\\n" "Starting Tor daemon"
    if hash systemctl 2>/dev/null; then
        if ! systemctl start tor.service >/dev/null 2>&1; then
            die "Can't start tor service, exiting!"
        fi
    else
        tor &  # Fallback, but may not work well
        sleep 5
    fi

    # Set firewall rules
    setup_firewall set

    printf "\\n${b}${green}%s${reset} %s\\n" \
            "[OK]" "ImposTOR is active, your system is routing under Tor"

    # Start auto-restart if interval set
    if [[ ${ip_change_interval} -gt 0 ]]; then
        auto_restart_tor &
        auto_restart_pid=$!
        msg "Auto IP change enabled every ${ip_change_interval} seconds"
    fi
}

stop_proxy() {
    check_root

    if pgrep -x "tor" > /dev/null; then
        info "Stopping Transparent Proxy"

        # Stop auto-restart
        if [[ ! -z "${auto_restart_pid}" ]]; then
            kill ${auto_restart_pid} 2>/dev/null
            auto_restart_pid=""
        fi

        # Restore firewall
        setup_firewall restore

        # Stop Tor
        printf "%s\\n" "Stop Tor"
        if hash systemctl 2>/dev/null; then
            systemctl stop tor.service
        else
            killall tor
        fi

        # Restore resolv.conf
        printf "%s\\n" "Restore default DNS"
        if hash resolvconf 2>/dev/null; then
            resolvconf -u
        else
            cp "${backup_dir}/resolv.conf.backup" /etc/resolv.conf
        fi

        # Restore torrc
        printf "%s\\n" "Restoring original /etc/tor/torrc"
        cp "${backup_dir}/torrc.backup" /etc/tor/torrc

        # Clean backups
        rm -rf "${backup_dir}"

        printf "\\n${b}${green}%s${reset} %s\\n" "[-]" "ImposTOR has stopped"
    else
        skip "Tor is not running!"
    fi
}

## Restart Tor to change IP
restart_tor() {
    check_root

    if pgrep -x "tor" > /dev/null; then
        info "Restarting Tor to change IP"

        if hash systemctl 2>/dev/null; then
            systemctl restart tor.service
        else
            killall tor
            tor &
        fi
    else
        skip "Tor is not running!"
        info "Starting Tor daemon..."
        systemctl start tor
    fi
}

## Background function for auto IP change
auto_restart_tor() {
    while true; do
        sleep ${ip_change_interval}
        restart_tor
    done
}

set_ip_interval() {
    read -p "Enter IP change interval in seconds (0 to disable): " new_interval
    if [[ ${new_interval} =~ ^[0-9]+$ ]]; then
        ip_change_interval=${new_interval}
        msg "IP change interval has been set to ${ip_change_interval} seconds"

        # Restart background if running
        if [[ ! -z "${auto_restart_pid}" ]]; then
            kill ${auto_restart_pid} 2>/dev/null
            auto_restart_pid=""
        fi
        if [[ ${ip_change_interval} -gt 0 && $(pgrep -x "tor") ]]; then
            auto_restart_tor &
            auto_restart_pid=$!
        fi
    else
        skip "Invalid input, must be a number"
    fi
}

help(){
    cat << EOF
    Usage: ImposTOR [command]

    Commands:
    start       Start the proxy
    stop        Stop the proxy
    restart     Restart Tor
    status      Check the status
    initip      Change the duration of IP change
    v           Print the software version
    help        Print this help message
    exit        Exit the tool
EOF
}

print_version() {
    printf "%s\\n" "» ${prog_name} v${version}"
    printf "%s\\n" "» ${signature}"
    printf "%s\\n\\n" "» License GNU GPL version 3"
}

get_query(){
    printf "%s\\n" "» Type 'help' to view all commands"
    while true; do
        query "" && read -r input

        case "${input}" in
            help) help ;;
            start) start_proxy ;;
            stop) stop_proxy ;;
            restart) restart_tor ;;
            status) check_status ;;
            initip) set_ip_interval ;;
            v) print_version ;;
            exit) exit 0 ;;
            clear) clear && banner ;;
            *) skip "Invalid option: ${input}, type 'help' for commands" ;;
        esac
        printf "\\n"
    done
}

clear
banner
check_root
get_query
